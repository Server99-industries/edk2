From eb58c41d497a229f4412d9afd212978943d12c0e Mon Sep 17 00:00:00 2001
From: Laszlo Ersek <lersek@redhat.com>
Date: Sun, 14 Feb 2016 08:17:16 +0100
Subject: [PATCH] BaseTools: LzmaCompress: eliminate _maxMode and bogus
 indentation

The "_maxMode" variable doesn't exist in edk2's variant of LzmaCompress,
but the way one of the old uses of the variable is commented out (i.e.,
together with the enclosing "if" statement) triggers the
"misleading-indentation" warning that is new in gcc-6.0, for the block of
code that originally depended on the "if" statement. Gcc believes
(mistakenly) that the programmer believes (mistakenly) that the block
depends on (repIndex == 0) higher up.

Remove the commented out uses of "_maxMode", and unindent the block in
question.

This patch is best viewed with "git show -b".

Cc: Cole Robinson <crobinso@redhat.com>
Cc: Yonghong Zhu <yonghong.zhu@intel.com>
Cc: Liming Gao <liming.gao@intel.com>
Reported-by: Cole Robinson <crobinso@redhat.com>
Contributed-under: TianoCore Contribution Agreement 1.0
Signed-off-by: Laszlo Ersek <lersek@redhat.com>
---
 BaseTools/Source/C/LzmaCompress/Sdk/C/LzmaEnc.c | 81 ++++++++++----------
 1 file changed, 40 insertions(+), 41 deletions(-)

diff --git a/BaseTools/Source/C/LzmaCompress/Sdk/C/LzmaEnc.c b/BaseTools/Source/C/LzmaCompress/Sdk/C/LzmaEnc.c
index 9b2dd16ffa48..1eb9898b5291 100644
--- a/BaseTools/Source/C/LzmaCompress/Sdk/C/LzmaEnc.c
+++ b/BaseTools/Source/C/LzmaCompress/Sdk/C/LzmaEnc.c
@@ -1367,52 +1367,51 @@ static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
       if (repIndex == 0)
         startLen = lenTest + 1;
         
-      /* if (_maxMode) */
+      {
+        UInt32 lenTest2 = lenTest + 1;
+        UInt32 limit = lenTest2 + p->numFastBytes;
+        UInt32 nextRepMatchPrice;
+        if (limit > numAvailFull)
+          limit = numAvailFull;
+        for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
+        lenTest2 -= lenTest + 1;
+        if (lenTest2 >= 2)
         {
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p->numFastBytes;
-          UInt32 nextRepMatchPrice;
-          if (limit > numAvailFull)
-            limit = numAvailFull;
-          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 >= 2)
+          UInt32 state2 = kRepNextStates[state];
+          UInt32 posStateNext = (position + lenTest) & p->pbMask;
+          UInt32 curAndLenCharPrice =
+              price + p->repLenEnc.prices[posState][lenTest - 2] +
+              GET_PRICE_0(p->isMatch[state2][posStateNext]) +
+              LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                  data[lenTest], data2[lenTest], p->ProbPrices);
+          state2 = kLiteralNextStates[state2];
+          posStateNext = (position + lenTest + 1) & p->pbMask;
+          nextRepMatchPrice = curAndLenCharPrice +
+              GET_PRICE_1(p->isMatch[state2][posStateNext]) +
+              GET_PRICE_1(p->isRep[state2]);
+
+          /* for (; lenTest2 >= 2; lenTest2--) */
           {
-            UInt32 state2 = kRepNextStates[state];
-            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-            UInt32 curAndLenCharPrice =
-                price + p->repLenEnc.prices[posState][lenTest - 2] +
-                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-                    data[lenTest], data2[lenTest], p->ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (position + lenTest + 1) & p->pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p->isRep[state2]);
-            
-            /* for (; lenTest2 >= 2; lenTest2--) */
+            UInt32 curAndLenPrice;
+            COptimal *opt;
+            UInt32 offset = cur + lenTest + 1 + lenTest2;
+            while (lenEnd < offset)
+              p->opt[++lenEnd].price = kInfinityPrice;
+            curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+            opt = &p->opt[offset];
+            if (curAndLenPrice < opt->price)
             {
-              UInt32 curAndLenPrice;
-              COptimal *opt;
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              while (lenEnd < offset)
-                p->opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-              opt = &p->opt[offset];
-              if (curAndLenPrice < opt->price)
-              {
-                opt->price = curAndLenPrice;
-                opt->posPrev = cur + lenTest + 1;
-                opt->backPrev = 0;
-                opt->prev1IsChar = True;
-                opt->prev2 = True;
-                opt->posPrev2 = cur;
-                opt->backPrev2 = repIndex;
-              }
+              opt->price = curAndLenPrice;
+              opt->posPrev = cur + lenTest + 1;
+              opt->backPrev = 0;
+              opt->prev1IsChar = True;
+              opt->prev2 = True;
+              opt->posPrev2 = cur;
+              opt->backPrev2 = repIndex;
             }
           }
         }
+      }
     }
     }
     /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
@@ -1456,7 +1455,7 @@ static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
           opt->prev1IsChar = False;
         }
 
-        if (/*_maxMode && */lenTest == matches[offs])
+        if (lenTest == matches[offs])
         {
           /* Try Match + Literal + Rep0 */
           const Byte *data2 = data - (curBack + 1);
-- 
1.8.3.1

